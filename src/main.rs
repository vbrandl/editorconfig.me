extern crate hyper;
extern crate reroute;

use std::fs::File;
use std::io::{BufReader, Result};
use std::io::prelude::*;
use std::env;

use hyper::Server;
use hyper::server::{Request, Response};
use reroute::{Captures, RouterBuilder};

static INDEX: &'static str = include_str!("../static/index.html");

fn not_found(_: Request, res: Response, _: Captures) {
    res.send(INDEX.as_bytes()).unwrap();
}

fn parse_capture(cap: &String) -> Vec<String> {
    let caps: Vec<&str> = cap.split(|c| c == ',' || c == '/').collect();
    let mut list: Vec<String> = Vec::new();
    // &caps[2..] is used to skip `/api/`
    for val in &caps[2..] {
        if val.is_empty() {
            continue;
        }
        list.push(val.to_string());
    }
    list.sort();
    list.dedup();
    list
}

fn list_handler(_: Request, res: Response, c: Captures) {
    let cap = c.unwrap();
    let caps = parse_capture(&cap[0]);
    let mut re = "; Generated by editorconfig.me\n; EditorConfig helps developers define and maintain consistent\n; coding styles between different editors and IDEs\n; editorconfig.org\n\n".to_string();

    for target in caps {
        let content = match read_file(&get_file_name(&target)) {
            Ok(c) => c,
            Err(e) => {
                println!("Could not process '{}'. {:?}", target, e);
                format!("; Could not process '{}'\n", target)
            }
        };
        re.push_str(&content);
        re.push_str("\n");
    }
    res.send(re.as_bytes()).unwrap();
}

fn get_file_name(name: &String) -> String {
    let mut full_name = "./files/".to_string();
    full_name.push_str(&name);
    full_name.push_str(".editorconfig");
    full_name
}

fn read_file(name: &String) -> Result<String> {
    let file = File::open(name)?;
    let mut reader = BufReader::new(file);
    let mut contents = String::new();

    reader.read_to_string(&mut contents)?;

    Ok(contents)
}

/// Look up the server port in PORT for heroku or use 8080 as fallback
fn get_server_port() -> String {
    env::var("PORT").unwrap_or("8080".to_string())
}

fn main() {
    let mut builder = RouterBuilder::new();

    builder.get(r"/api/(,?(\w)*)+", list_handler);

    builder.not_found(not_found);

    let router = builder.finalize().unwrap();

    let mut listen = "0.0.0.0:".to_string();
    listen.push_str(&get_server_port());
    Server::http(&listen).unwrap().handle(router).unwrap();
}

#[test]
fn test_parse_capture() {
    let actual = parse_capture(&"/api/,rust,,markdown,,,rust,".to_string());
    let expected: Vec<String> = vec!["markdown".to_string(), "rust".to_string()]
        .into_iter()
        .collect();
    assert_eq!(actual, expected);
}

#[test]
fn test_read_file() {
    let actual = read_file(&"test/testfile".to_string()).unwrap();
    let expected = "testtesttest\n".to_string();
    assert_eq!(actual, expected);
}

#[test]
fn test_get_file_name() {
    let actual = get_file_name(&"rust".to_string());
    let expected = "./files/rust.editorconfig".to_string();
    assert_eq!(actual, expected);
}
